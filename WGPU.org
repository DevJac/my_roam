:PROPERTIES:
:ID:       e7da0025-a124-41fc-a18d-1fce1f21d59f
:END:
#+title: WGPU
* WGPU Spec Notes
** Concepts
*** Adapter
The physical GPU hardware.
*** Device / Queue
A /connection/ to the Adapter, and the Queue which executes commands.
*** Buffer / Texture
Resources stored in GPU memory.
*** CommandBuffer / RenderBundle
Contain user-recorded commands.
**** CommandEncoder
CommandEncoder is created from a Device.

CommandEncoder may create a Pass, and a Pass may have a Pipeline. There are RenderPass, RenderPipeline, ComputePass, and ComputePipeline.

CommandEncoder may be finalized into a CommandBuffer and subbmited to a Queue for execution.

Most configuration happens in a Pipeline, the rest comes from Passes or other special functions.
*** ShaderModule
Contains shader code.
*** Sample / BindGroup
Configure the way Buffers and Textures are used by the GPU.
** Coordinate systems
*** Pixel independent
These coordinate systems has no notion of a pixel.
**** Normalized device coordinates
(x, y, z)

Coordinates contained in a normal unit-cube.
**** Clip space coordinates
(x, y, z, w)

Coordinates contained within a scaled unit-cube; the scaling factor is w.
*** Pixel dependent
**** Framebuffer coordinates / window coordinates / present coordinates
(x, y)

Coordinates correspond to pixels. (0, 0) is top-left.
**** Viewport coordinates / fragment coordinates
(x, y, z)

Like framebuffer coordinates, but with depth z: 0 <= z <= 1.
*** UV coordinates
(u, v)

Texture coordinates: 0 <= u <= 1, 0 <= v <= 1
* WGPU
** Concepts
*** Window
A ~Window~ is not provided by WGPU, but by other crates.

Interoperability is provided through the ~raw-window-handle~ crate, which WGPU supports.
*** Instance
~Instance~ is the first thing you create when using WGPU.

~Instance~ is used to create ~Adapters~ and ~Surfaces~.

Does not have to be kept alive.
*** Adapter
Represents the physical device.

Can be used to create a ~Device~ and ~Queue~.

Does not have to be kept alive.
*** Device / Queue
A /connection/ to a ~Device~, and its command ~Queue~.
*** Surface
A canvas you can render to.

Created by ~Instance~ and requires a ~Window~.

Must be configured before presentation using ~Surface.configure~.
**** SurfaceTexture
May be ~presented~ to update the ~Window~ ~Surface~.

~SurfaceTexture::present~ should be called after ~Queue::submit~.
*** Texture
A GPU managed data structure.

You can get the ~Texture~ of a ~Surface~ with ~Surface::get_current_texture~.

You can create a ~Texture~ with ~Device::create_texture~.
**** TextureView
A reference to a ~Texture~. Requires by ~RenderPipeline~ or ~BindGroup~.
*** CommandEncoder
Records ~RenderPasses~, ~ComputePasses~, and transfer operations between driver-managed resources like ~Buffers~ and ~Textures~.

When finished, call ~CommandEncoder::finish~, this finalizes the ~CommandEncoder~ as a ~CommandBuffer~.

Has many methods.
**** CommandBuffer
Created by ~CommandEncoder::finish~.

Can only be ~submitted~ to a ~Queue~, and has no significant methods.
*** RenderPass
**** RenderPassDescriptor
***** Concepts
****** Color
****** Depth
****** Stencil
***** Fields
****** label: Option<str>
****** color_attachments: [Option<RenderPassColorAttachment>]
******* view: TextureView
******* resolve_target: Option<TextureView>
******* ops: Operations<Color>
******** store: bool
******** load: LoadOp<Color>
********* Clear<Color>
********* Load
****** depth_stencil_attachment: [Option<RenderPassDepthStencilAttachment>]
******* view: TextureView
******* depth_ops: Option<Operations<f32>>
******** store: bool
******** load: LoadOp<f32>
********* Clear<f32>
********* Load
******* stencil_ops: Option<Operations<u32>>
******** store: bool
******** load: LoadOp<u32>
********* Clear<u32>
********* Load
*** ShaderModule
A compiled shader. Created from the ~Driver~ using either source code or a SPIR-V binary.
*** TODO RenderPipeline
**** TODO RenderPipelineDescriptor
***** label
***** layout
***** vertex
***** fragment
***** primitive
***** depth_stencil
***** multisample
***** multiview
*** TODO PipelineLayout
*** TODO BindGroup
** Concept Threads
*** SurfaceTexture
1. Window
2. Instance
3. Surface
   Instance.create_surface(Window)
   Surface.configure(SurfaceConfiguration)
4. SurfaceTexture
5. Texture
6. TextureView
*** RenderPass
1. Instance
2. Adapter
3. Device / Queue
4. CommandEncoder
5. RenderPass
   Render to TextureView
6. CommandBuffer
   Submit CommandBuffer to Queue
   Present SurfaceTexture
*** RenderPipeline
1. Instance
2. Adapter
3. Device / Queue
4. ShaderModule
5. RenderPipeline
6. RenderPass
   RenderPass.set_pipeline(RenderPipeline)
* WebGPU
** Coordinate Systems
https://gpuweb.github.io/gpuweb/#coordinate-systems

The following will refer to x, y, z, and w of the vec4 (x, y, z, w).
*** Clip space coordinates
-w <= x, y <= +w
0 <= z <= +w
**** Normalized device coordinates
-1 <= x, y <= +1
0 <= z <= +1

Dividing clip space coordinates by w gives normalized device coordinates.
*** Framebuffer coordinates
Has 2 dimensions (x, y), each unit represents 1 pixel from the top-left.
* Shaders
** Types
*** Vertex
*** Fragment
*** Compute
* Resources
** Learn Wgpu
https://sotrh.github.io/learn-wgpu/
*** Progress
<2023-07-19> Finished "The Surface" tutorial
<2023-07-23> Finished "The Pipeline" tutorial; need to review RenderPipelineDescriptor again later
** WebGPU â€” All of the cores, none of the canvas
https://surma.dev/things/webgpu/
** WebGPU Standard
https://www.w3.org/TR/webgpu/
*** Progress
<2023-07-23> Read sections 1 and 2, Introduction, and Malicious use considerations
<2023-07-24> Read through section 3.5. Reading everything is not useful.
** WGSL Standard
https://www.w3.org/TR/WGSL/
** YouTube tutorial series by Dr. Xu
https://www.youtube.com/playlist?list=PL_UrKDEhALdJS0VrLPn7dqC5A4W1vCAUT
